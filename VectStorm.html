<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MineStorm Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            filter: blur(0.5px) brightness(1.2);
        }

        #root {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #starfield {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background-color: black;
            opacity: 0.3;
        }

        /* Add Vectrex screen effect */
        #root::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, transparent 50%, rgba(0, 0, 0, 0.3) 100%);
            pointer-events: none;
            z-index: 1;
        }

        /* Add screen curvature effect */
        #root::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                135deg,
                rgba(0, 40, 0, 0.1) 0%,
                rgba(0, 0, 0, 0) 50%,
                rgba(0, 40, 0, 0.1) 100%
            );
            pointer-events: none;
            z-index: 2;
            border-radius: 20% / 10%;
            box-shadow: inset 0 0 100px rgba(0, 30, 0, 0.2);
        }
    </style>
</head>
<body>
    <canvas id="starfield"></canvas>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>


    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // Constants to avoid magic numbers
        const CONSTANTS = {
            SHIP_SIZE: 10,
            STAR_SIZE: 20,
            STAR_COUNT: 5,
            DEATH_STAR_SIZE: 25,
            DEATH_STAR_COUNT: 2,
            DEATH_STAR_SPEED: 0.5,
            GRID_SECTIONS: 3,
            SECTION_MARGIN: 40,
            LASER_SPEED: 15,
            LASER_LENGTH: 20,
            SHIP_ROTATION_SPEED: 0.03,
            SHIP_ACCELERATION: 0.05,
            EXPLOSION_FRAMES: 60,
            SHIP_PARTICLES: 30,
            STAR_PARTICLES: 15,
            POWERUP_SIZE: 8,
            POWERUP_DURATION: 40 * 60, // 40 seconds * 60 fps
            POINTS_STAR: 10,
            POINTS_DEATH_STAR: 20,
            KILLS_FOR_POWERUP: 5,
            INITIAL_LIVES: 3,
            HIGH_SCORE_KEY: 'minestorm_high_score',
            SOUND_VOLUME: 0.3,
            VECTOR_COLOR: '#20ff20', // Vectrex green
            VECTOR_GLOW: '#40ff40',  // Brighter green for glow
            ENEMY_COLOR: '#80ff80',  // Lighter green for enemies
            ALERT_COLOR: '#ff4040',  // Red for alerts/damage
            LINE_WIDTH: 1.5,         // Thicker lines for vector look
            GLOW_BLUR: 4,           // Vector glow blur amount
        };

        // Utility functions
        const utils = {
            distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
            random: (min, max) => min + Math.random() * (max - min),
            clamp: (value, min, max) => Math.max(min, Math.min(max, value))
        };

        // Sound effects using Web Audio API
        const createAudioContext = () => {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            return new AudioContext();
        };

        const createOscillator = (context, type, frequency, duration) => {
            const oscillator = context.createOscillator();
            const gainNode = context.createGain();
            
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, context.currentTime);
            
            gainNode.gain.setValueAtTime(CONSTANTS.SOUND_VOLUME, context.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + duration);
            
            oscillator.connect(gainNode);
            gainNode.connect(context.destination);
            
            return oscillator;
        };

        const playSound = {
            laser: (context) => {
                const osc = createOscillator(context, 'sine', 880, 0.05);
                // Frequency sweep from high to low for pew effect
                osc.frequency.setValueAtTime(1200, context.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, context.currentTime + 0.05);
                osc.start();
                osc.stop(context.currentTime + 0.05);
            },
            explosion: (context) => {
                const osc = createOscillator(context, 'sawtooth', 100, 0.3);
                osc.frequency.exponentialRampToValueAtTime(20, context.currentTime + 0.3);
                osc.start();
                osc.stop(context.currentTime + 0.3);
            },
            powerUp: (context) => {
                const osc = createOscillator(context, 'sine', 440, 0.2);
                osc.frequency.exponentialRampToValueAtTime(880, context.currentTime + 0.2);
                osc.start();
                osc.stop(context.currentTime + 0.2);
            },
            levelUp: (context) => {
                const osc1 = createOscillator(context, 'sine', 440, 0.3);
                const osc2 = createOscillator(context, 'sine', 554.37, 0.3);
                const osc3 = createOscillator(context, 'sine', 659.25, 0.3);
                
                osc1.start(context.currentTime);
                osc2.start(context.currentTime + 0.1);
                osc3.start(context.currentTime + 0.2);
                
                osc1.stop(context.currentTime + 0.3);
                osc2.stop(context.currentTime + 0.3);
                osc3.stop(context.currentTime + 0.3);
            }
        };

        const App = () => {
            const canvasRef = useRef(null);
            const starfieldRef = useRef(null);
            const audioContextRef = useRef(null);
            const gameStateRef = useRef({
                ship: {
                    x: window.innerWidth/2,
                    y: window.innerHeight/2,
                    angle: 0,
                    speed: 0,
                    rotation: 0,
                    acceleration: 0,
                    powerUpTime: 0
                },
                lastDirection: { x: 0, y: 0 },
                targetDirection: { x: 0, y: 0 },
                lasers: [],
                stars: [],
                deathStars: [],
                explosionParticles: [],
                explosionTime: 0,
                score: 0,
                killCount: 0,
                powerUp: null,
                lives: CONSTANTS.INITIAL_LIVES,
                level: 1,
                highScore: parseInt(localStorage.getItem(CONSTANTS.HIGH_SCORE_KEY)) || 0
            });
            const [dimensions, setDimensions] = useState({
                width: window.innerWidth,
                height: window.innerHeight
            });
            const [gameState, setGameState] = useState('start'); // 'start', 'playing', 'paused', 'exploding', 'gameover'
            const lastShotTimeRef = useRef(0);
            const isSpaceHeldRef = useRef(false);
            const SHOT_COOLDOWN = 200; // 200ms = 5 shots per second

            // Add object pools
            const objectPools = useRef({
                lasers: Array(100).fill(null).map(() => ({ x: 0, y: 0, dx: 0, dy: 0, active: false })),
                particles: Array(200).fill(null).map(() => ({ x: 0, y: 0, dx: 0, dy: 0, life: 0, color: 'white', active: false }))
            });

            // Cache for frequently used calculations
            const cache = useRef({
                gridLines: null,
                starPoints: Array(10).fill(null).map((_, i) => {
                    const radius = i % 2 ? 0.5 : 1;
                    const angle = (Math.PI * i) / 5;
                    return {
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    };
                }),
                deathStarPoints: Array(16).fill(null).map((_, i) => {
                    const radius = i % 2 ? 0.7 : 1;
                    const angle = (Math.PI * i) / 8;
                    return {
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    };
                })
            });

            // Pre-calculate grid lines on resize
            const updateGridCache = useCallback(() => {
                const gridSize = Math.min(dimensions.width, dimensions.height) / 30;
                const lines = [];
                
                for (let x = 0; x < dimensions.width; x += gridSize) {
                    lines.push({ x1: x, y1: 0, x2: x, y2: dimensions.height });
                }
                for (let y = 0; y < dimensions.height; y += gridSize) {
                    lines.push({ x1: 0, y1: y, x2: dimensions.width, y2: y });
                }
                
                cache.current.gridLines = lines;
            }, [dimensions]);

            // Optimized laser creation using object pool
            const createLaser = useCallback((ship, angle) => {
                const pool = objectPools.current.lasers;
                const laser = pool.find(l => !l.active);
                if (laser) {
                    laser.x = ship.x + Math.cos(angle) * 15;
                    laser.y = ship.y + Math.sin(angle) * 15;
                    laser.dx = Math.cos(angle);
                    laser.dy = Math.sin(angle);
                    laser.active = true;
                    return laser;
                }
                return null;
            }, []);

            // Optimized explosion creation using object pool
            const createExplosion = useCallback((x, y, isShip) => {
                const particleCount = isShip ? CONSTANTS.SHIP_PARTICLES : CONSTANTS.STAR_PARTICLES;
                const pool = objectPools.current.particles;
                const color = isShip ? 'white' : 'yellow';
                
                // Deactivate all existing particles if this is a ship explosion
                if (isShip) {
                    pool.forEach(p => p.active = false);
                }
                
                let created = 0;
                for (const particle of pool) {
                    if (!particle.active && created < particleCount) {
                        const angle = (Math.PI * 2 * created) / particleCount;
                        const speed = utils.random(2, 4);
                        particle.x = x;
                        particle.y = y;
                        particle.dx = Math.cos(angle) * speed;
                        particle.dy = Math.sin(angle) * speed;
                        particle.life = 1;
                        particle.color = color;
                        particle.active = true;
                        created++;
                    }
                }

                if (isShip) {
                    setGameState('exploding');
                    gameStateRef.current.explosionTime = CONSTANTS.EXPLOSION_FRAMES;
                }
            }, []);

            // Initialize audio context
            useEffect(() => {
                // Create audio context on component mount but don't start it
                audioContextRef.current = createAudioContext();
                
                // Function to initialize audio on first interaction
                const initAudio = () => {
                    if (audioContextRef.current && audioContextRef.current.state === 'suspended') {
                        audioContextRef.current.resume();
                    }
                    // Remove listeners after first interaction
                    window.removeEventListener('keydown', initAudio);
                    window.removeEventListener('click', initAudio);
                    window.removeEventListener('touchstart', initAudio);
                };

                // Add listeners for user interaction
                window.addEventListener('keydown', initAudio);
                window.addEventListener('click', initAudio);
                window.addEventListener('touchstart', initAudio);

                return () => {
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                    }
                    // Clean up listeners
                    window.removeEventListener('keydown', initAudio);
                    window.removeEventListener('click', initAudio);
                    window.removeEventListener('touchstart', initAudio);
                };
            }, []);

            // Draw start screen
            const drawStartScreen = useCallback((ctx) => {
                const time = Date.now() / 1000;
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, dimensions.width, dimensions.height);
                
                // Draw vector grid background
                ctx.strokeStyle = 'rgb(20, 20, 20)';
                ctx.lineWidth = 1;
                const gridSize = 50;
                for (let x = 0; x < dimensions.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, dimensions.height);
                    ctx.stroke();
                }
                for (let y = 0; y < dimensions.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(dimensions.width, y);
                    ctx.stroke();
                }

                // Draw title with vector effect
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height / 3);
                
                // Draw multiple layers of the title with offset for vector effect
                const layers = 3;
                for (let i = layers; i >= 0; i--) {
                    const offset = i * 2;
                    const alpha = i === layers ? 1 : 0.3;
                    ctx.strokeStyle = `rgba(255, ${i * 80}, 0, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.font = '72px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    ctx.strokeText('MINESTORM', offset, offset);
                }
                
                // Draw main title
                ctx.fillStyle = 'white';
                ctx.font = '72px "Courier New", monospace';
                ctx.fillText('MINESTORM', 0, 0);
                ctx.restore();

                // Draw vector decorations
                ctx.save();
                ctx.strokeStyle = 'rgb(50, 50, 255)';
                ctx.lineWidth = 2;
                
                // Draw pulsing corner brackets
                const cornerSize = 40 + Math.sin(time * 2) * 10;
                const margin = 100;
                
                // Top-left corner
                ctx.beginPath();
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin, margin + cornerSize);
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin + cornerSize, margin);
                ctx.stroke();
                
                // Top-right corner
                ctx.beginPath();
                ctx.moveTo(dimensions.width - margin, margin);
                ctx.lineTo(dimensions.width - margin - cornerSize, margin);
                ctx.moveTo(dimensions.width - margin, margin);
                ctx.lineTo(dimensions.width - margin, margin + cornerSize);
                ctx.stroke();
                
                // Bottom-left corner
                ctx.beginPath();
                ctx.moveTo(margin, dimensions.height - margin);
                ctx.lineTo(margin, dimensions.height - margin - cornerSize);
                ctx.moveTo(margin, dimensions.height - margin);
                ctx.lineTo(margin + cornerSize, dimensions.height - margin);
                ctx.stroke();
                
                // Bottom-right corner
                ctx.beginPath();
                ctx.moveTo(dimensions.width - margin, dimensions.height - margin);
                ctx.lineTo(dimensions.width - margin - cornerSize, dimensions.height - margin);
                ctx.moveTo(dimensions.width - margin, dimensions.height - margin);
                ctx.lineTo(dimensions.width - margin, dimensions.height - margin - cornerSize);
                ctx.stroke();
                
                ctx.restore();

                // Draw instructions with scan line effect
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height / 2);
                
                const instructions = [
                    '< CONTROLS >',
                    '[↑] THRUST',
                    '[←][→] ROTATE',
                    '[SPACE] FIRE',
                    '[P] PAUSE'
                ];

                instructions.forEach((text, i) => {
                    const y = i * 40;
                    // Scan line effect
                    const scanOffset = Math.sin(time * 3 + i * 0.5) * 3;
                    
                    ctx.font = '24px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    
                    // Draw text shadow
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.fillText(text, scanOffset, y + 2);
                    
                    // Draw main text
                    ctx.fillStyle = i === 0 ? 'rgb(0, 255, 255)' : 'white';
                    ctx.fillText(text, 0, y);
                });
                ctx.restore();

                // Draw high score with glowing effect
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height * 0.8);
                
                const glowIntensity = (Math.sin(time * 2) + 1) / 2;
                const glowColor = `rgba(255, 255, 0, ${glowIntensity * 0.5})`;
                
                ctx.font = '32px "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 20;
                ctx.fillStyle = 'yellow';
                ctx.fillText(`HIGH SCORE: ${gameStateRef.current.highScore}`, 0, 0);
                ctx.restore();

                // Draw blinking "Press SPACE to start" text
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height * 0.9);
                
                if (Math.sin(time * 4) > 0) {
                    ctx.font = '28px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'rgb(0, 255, 0)';
                    ctx.fillText('>> PRESS SPACE TO START <<', 0, 0);
                }
                ctx.restore();
            }, [dimensions]);

            // Draw game over screen
            const drawGameOverScreen = useCallback((ctx) => {
                const state = gameStateRef.current;
                const time = Date.now() / 1000;
                
                // Draw background
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, dimensions.width, dimensions.height);
                
                // Draw vector grid background
                ctx.strokeStyle = 'rgb(20, 20, 20)';
                ctx.lineWidth = 1;
                const gridSize = 50;
                for (let x = 0; x < dimensions.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, dimensions.height);
                    ctx.stroke();
                }
                for (let y = 0; y < dimensions.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(dimensions.width, y);
                    ctx.stroke();
                }

                // Center all text
                ctx.textAlign = 'center';

                // Draw "GAME OVER" with vector effect
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height * 0.3);
                
                // Draw multiple layers with offset for vector effect
                const layers = 3;
                for (let i = layers; i >= 0; i--) {
                    const offset = i * 2;
                    const alpha = i === layers ? 1 : 0.3;
                    ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.font = '72px "Courier New", monospace';
                    ctx.strokeText('GAME OVER', 0, 0);
                }
                
                // Draw main text
                ctx.fillStyle = 'white';
                ctx.font = '72px "Courier New", monospace';
                ctx.fillText('GAME OVER', 0, 0);
                ctx.restore();

                // Draw score with scan line effect
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height * 0.45);
                const scanOffset = Math.sin(time * 3) * 3;
                
                ctx.font = '36px "Courier New", monospace';
                
                // Draw score shadow
                ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.fillText(`SCORE: ${state.score}`, scanOffset, 0);
                
                // Draw main score
                ctx.fillStyle = 'rgb(0, 255, 255)';
                ctx.fillText(`SCORE: ${state.score}`, 0, 0);
                ctx.restore();

                // Draw new high score with glowing effect if achieved
                if (state.score > state.highScore) {
                    ctx.save();
                    ctx.translate(dimensions.width / 2, dimensions.height * 0.55);
                    
                    const glowIntensity = (Math.sin(time * 2) + 1) / 2;
                    ctx.shadowColor = `rgba(255, 255, 0, ${glowIntensity})`;
                    ctx.shadowBlur = 20;
                    
                    ctx.font = '32px "Courier New", monospace';
                    ctx.fillStyle = 'yellow';
                    ctx.fillText('NEW HIGH SCORE!', 0, 0);
                    ctx.restore();
                }

                // Draw high score with vector effect
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height * 0.65);
                
                const highScoreGlow = (Math.sin(time * 2) + 1) / 2;
                ctx.shadowColor = `rgba(255, 255, 0, ${highScoreGlow * 0.5})`;
                ctx.shadowBlur = 15;
                
                ctx.font = '32px "Courier New", monospace';
                ctx.fillStyle = 'yellow';
                ctx.fillText(`HIGH SCORE: ${state.highScore}`, 0, 0);
                ctx.restore();

                // Draw blinking restart text
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height * 0.8);
                
                if (Math.sin(time * 4) > 0) {
                    ctx.font = '28px "Courier New", monospace';
                    ctx.fillStyle = 'rgb(0, 255, 0)';
                    ctx.fillText('>> PRESS SPACE TO RESTART <<', 0, 0);
                }
                ctx.restore();

                // Draw corner brackets
                ctx.save();
                ctx.strokeStyle = 'rgb(50, 50, 255)';
                ctx.lineWidth = 2;
                
                const cornerSize = 40 + Math.sin(time * 2) * 10;
                const margin = 100;
                
                // Top-left corner
                ctx.beginPath();
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin, margin + cornerSize);
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin + cornerSize, margin);
                ctx.stroke();
                
                // Top-right corner
                ctx.beginPath();
                ctx.moveTo(dimensions.width - margin, margin);
                ctx.lineTo(dimensions.width - margin - cornerSize, margin);
                ctx.moveTo(dimensions.width - margin, margin);
                ctx.lineTo(dimensions.width - margin, margin + cornerSize);
                ctx.stroke();
                
                // Bottom-left corner
                ctx.beginPath();
                ctx.moveTo(margin, dimensions.height - margin);
                ctx.lineTo(margin, dimensions.height - margin - cornerSize);
                ctx.moveTo(margin, dimensions.height - margin);
                ctx.lineTo(margin + cornerSize, dimensions.height - margin);
                ctx.stroke();
                
                // Bottom-right corner
                ctx.beginPath();
                ctx.moveTo(dimensions.width - margin, dimensions.height - margin);
                ctx.lineTo(dimensions.width - margin - cornerSize, dimensions.height - margin);
                ctx.moveTo(dimensions.width - margin, dimensions.height - margin);
                ctx.lineTo(dimensions.width - margin, dimensions.height - margin - cornerSize);
                ctx.stroke();
                
                ctx.restore();
            }, [dimensions]);

            // Draw pause screen
            const drawPauseScreen = useCallback((ctx) => {
                const time = Date.now() / 1000;
                
                // Semi-transparent background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, dimensions.width, dimensions.height);
                
                // Draw vector grid background
                ctx.strokeStyle = 'rgb(20, 20, 20)';
                ctx.lineWidth = 1;
                const gridSize = 50;
                for (let x = 0; x < dimensions.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, dimensions.height);
                    ctx.stroke();
                }
                for (let y = 0; y < dimensions.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(dimensions.width, y);
                    ctx.stroke();
                }

                // Draw "PAUSED" with vector effect
                ctx.save();
                ctx.translate(dimensions.width / 2, dimensions.height / 2);
                
                // Draw multiple layers with offset for vector effect
                const layers = 3;
                for (let i = layers; i >= 0; i--) {
                    const offset = i * 2;
                    const alpha = i === layers ? 1 : 0.3;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.font = '72px "Courier New", monospace';
                    ctx.textAlign = 'center';
                    ctx.strokeText('PAUSED', offset, offset);
                }
                
                // Draw main text
                ctx.fillStyle = 'white';
                ctx.font = '72px "Courier New", monospace';
                ctx.fillText('PAUSED', 0, 0);

                // Draw blinking "Press P to resume" text
                if (Math.sin(time * 4) > 0) {
                    ctx.font = '28px "Courier New", monospace';
                    ctx.fillStyle = 'rgb(0, 255, 0)';
                    ctx.fillText('>> PRESS P TO RESUME <<', 0, 80);
                }
                
                ctx.restore();

                // Draw corner brackets
                ctx.save();
                ctx.strokeStyle = 'rgb(50, 50, 255)';
                ctx.lineWidth = 2;
                
                const cornerSize = 40 + Math.sin(time * 2) * 10;
                const margin = 100;
                
                // Top-left corner
                ctx.beginPath();
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin, margin + cornerSize);
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin + cornerSize, margin);
                ctx.stroke();
                
                // Top-right corner
                ctx.beginPath();
                ctx.moveTo(dimensions.width - margin, margin);
                ctx.lineTo(dimensions.width - margin - cornerSize, margin);
                ctx.moveTo(dimensions.width - margin, margin);
                ctx.lineTo(dimensions.width - margin, margin + cornerSize);
                ctx.stroke();
                
                // Bottom-left corner
                ctx.beginPath();
                ctx.moveTo(margin, dimensions.height - margin);
                ctx.lineTo(margin, dimensions.height - margin - cornerSize);
                ctx.moveTo(margin, dimensions.height - margin);
                ctx.lineTo(margin + cornerSize, dimensions.height - margin);
                ctx.stroke();
                
                // Bottom-right corner
                ctx.beginPath();
                ctx.moveTo(dimensions.width - margin, dimensions.height - margin);
                ctx.lineTo(dimensions.width - margin - cornerSize, dimensions.height - margin);
                ctx.moveTo(dimensions.width - margin, dimensions.height - margin);
                ctx.lineTo(dimensions.width - margin, dimensions.height - margin - cornerSize);
                ctx.stroke();
                
                ctx.restore();
            }, [dimensions]);

            const createStars = useCallback(() => {
                const { width, height } = dimensions;
                return Array.from({ length: CONSTANTS.STAR_COUNT }, () => {
                    // Place stars at the edges of the screen
                    const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                    let x, y;
                    
                    switch(side) {
                        case 0: // top
                            x = utils.random(0, width);
                            y = -CONSTANTS.STAR_SIZE;
                            break;
                        case 1: // right
                            x = width + CONSTANTS.STAR_SIZE;
                            y = utils.random(0, height);
                            break;
                        case 2: // bottom
                            x = utils.random(0, width);
                            y = height + CONSTANTS.STAR_SIZE;
                            break;
                        default: // left
                            x = -CONSTANTS.STAR_SIZE;
                            y = utils.random(0, height);
                    }
                    
                    return {
                        x,
                        y,
                        size: CONSTANTS.STAR_SIZE,
                        angle: Math.random() * Math.PI * 2,
                        rotationSpeed: utils.random(-0.003, 0.003)
                    };
                });
            }, [dimensions]);

            const createDeathStars = useCallback(() => {
                const { width, height } = dimensions;
                return Array.from({ length: CONSTANTS.DEATH_STAR_COUNT }, () => {
                    // Place death stars at the edges of the screen
                    const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                    let x, y;
                    
                    switch(side) {
                        case 0: // top
                            x = utils.random(0, width);
                            y = -CONSTANTS.DEATH_STAR_SIZE;
                            break;
                        case 1: // right
                            x = width + CONSTANTS.DEATH_STAR_SIZE;
                            y = utils.random(0, height);
                            break;
                        case 2: // bottom
                            x = utils.random(0, width);
                            y = height + CONSTANTS.DEATH_STAR_SIZE;
                            break;
                        default: // left
                            x = -CONSTANTS.DEATH_STAR_SIZE;
                            y = utils.random(0, height);
                    }
                    
                    return {
                        x,
                        y,
                        size: CONSTANTS.DEATH_STAR_SIZE,
                        angle: Math.random() * Math.PI * 2,
                        rotationSpeed: utils.random(-0.002, 0.002)
                    };
                });
            }, [dimensions]);

            const createSingleEnemy = useCallback((type = 'random') => {
                const { width, height } = dimensions;
                // Place enemy at the edges of the screen
                const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                let x, y;
                
                switch(side) {
                    case 0: // top
                        x = utils.random(0, width);
                        y = -CONSTANTS.STAR_SIZE;
                        break;
                    case 1: // right
                        x = width + CONSTANTS.STAR_SIZE;
                        y = utils.random(0, height);
                        break;
                    case 2: // bottom
                        x = utils.random(0, width);
                        y = height + CONSTANTS.STAR_SIZE;
                        break;
                    default: // left
                        x = -CONSTANTS.STAR_SIZE;
                        y = utils.random(0, height);
                }

                // Determine enemy type if random
                const isDeathStar = type === 'random' ? Math.random() < 0.3 : type === 'death';
                
                // For yellow stars, place them directly in the play area instead of at edges
                if (!isDeathStar) {
                    x = utils.random(CONSTANTS.STAR_SIZE * 2, width - CONSTANTS.STAR_SIZE * 2);
                    y = utils.random(CONSTANTS.STAR_SIZE * 2, height - CONSTANTS.STAR_SIZE * 2);
                }
                
                return {
                    x,
                    y,
                    size: isDeathStar ? CONSTANTS.DEATH_STAR_SIZE : CONSTANTS.STAR_SIZE,
                    angle: Math.random() * Math.PI * 2,
                    rotationSpeed: utils.random(-0.003, 0.003),
                    type: isDeathStar ? 'death' : 'yellow'
                };
            }, [dimensions]);

            const spawnRandomEnemy = useCallback(() => {
                const state = gameStateRef.current;
                const totalEnemies = state.stars.filter(Boolean).length + state.deathStars.length;
                const ship = state.ship;
                
                if (totalEnemies < 7) { // Keep maximum 7 enemies
                    // Count current enemy types
                    const redCount = state.deathStars.length;
                    const yellowCount = state.stars.filter(Boolean).length;
                    
                    // Determine type based on current balance
                    let enemyType = 'yellow'; // Default to yellow stars
                    if (yellowCount >= 5) enemyType = 'death'; // Only spawn death stars if we have enough yellow ones
                    
                    const enemy = createSingleEnemy(enemyType);
                    
                    // Add enemy to appropriate array
                    if (enemy.type === 'death') {
                        state.deathStars.push(enemy);
                    } else {
                        // Find first null position or push to end
                        const nullIndex = state.stars.indexOf(null);
                        if (nullIndex !== -1) {
                            state.stars[nullIndex] = enemy;
                        } else {
                            state.stars.push(enemy);
                        }
                    }
                }
            }, [dimensions, createSingleEnemy]);

            const resetGame = useCallback(() => {
                const state = gameStateRef.current;
                state.ship = {
                    x: dimensions.width / 2,
                    y: dimensions.height / 2,
                    angle: 0,
                    speed: 0,
                    rotation: 0,
                    acceleration: 0,
                    powerUpTime: 0
                };
                state.lastDirection = { x: 0, y: 0 };
                state.targetDirection = { x: 0, y: 0 };
                state.lasers = [];
                state.stars = [];
                state.deathStars = [];
                state.explosionParticles = [];
                state.explosionTime = 0;
                state.score = 0;
                state.killCount = 0;
                state.powerUp = null;
                state.lives = CONSTANTS.INITIAL_LIVES;
                state.level = 1;
                
                // Create initial enemies with more yellow stars
                for (let i = 0; i < 3; i++) {
                    // Force yellow stars
                    const yellowStar = createSingleEnemy('yellow');
                    state.stars.push(yellowStar);
                }
                
                // Add some death stars
                for (let i = 0; i < 2; i++) {
                    const deathStar = createSingleEnemy('death');
                    state.deathStars.push(deathStar);
                }
            }, [dimensions, createSingleEnemy]);

            const createPowerUp = useCallback(() => {
                const { width, height } = dimensions;
                return {
                    x: utils.random(CONSTANTS.POWERUP_SIZE, width - CONSTANTS.POWERUP_SIZE),
                    y: utils.random(CONSTANTS.POWERUP_SIZE, height - CONSTANTS.POWERUP_SIZE),
                    size: CONSTANTS.POWERUP_SIZE,
                    pulsePhase: 0
                };
            }, [dimensions]);

            const updateGameState = useCallback(() => {
                const state = gameStateRef.current;
                const { ship, lastDirection } = state;

                // Update particles
                objectPools.current.particles.forEach(particle => {
                    if (particle.active) {
                        particle.x += particle.dx;
                        particle.y += particle.dy;
                        particle.life -= 0.02;
                        if (particle.life <= 0) {
                            particle.active = false;
                        }
                    }
                });

                if (gameState === 'exploding') {
                    state.explosionTime--;
                    // Only transition to game over when both timer is done and particles are gone
                    if (state.explosionTime <= 0) {
                        const activeParticles = objectPools.current.particles.some(p => p.active);
                        if (!activeParticles) {
                            if (state.lives <= 0) {
                                if (state.score > state.highScore) {
                                    state.highScore = state.score;
                                    localStorage.setItem(CONSTANTS.HIGH_SCORE_KEY, state.score.toString());
                                }
                                setGameState('gameover');
                            } else {
                                setGameState('playing');
                            }
                        }
                    }
                    return; // Don't update other game state while exploding
                }

                if (gameState === 'playing') {
                    // Auto-fire when space is held
                    if (isSpaceHeldRef.current) {
                        const currentTime = Date.now();
                        // Enforce strict timing
                        if (currentTime - lastShotTimeRef.current >= SHOT_COOLDOWN) {
                            const angle = state.ship.angle;
                            let shotFired = false;
                            
                            if (state.ship.powerUpTime > 0) {
                                const laser1 = createLaser(state.ship, angle - 0.1);
                                const laser2 = createLaser(state.ship, angle + 0.1);
                                if (laser1 && laser2) {
                                    shotFired = true;
                                }
                            } else {
                                const laser = createLaser(state.ship, angle);
                                if (laser) {
                                    shotFired = true;
                                }
                            }

                            if (shotFired) {
                                if (audioContextRef.current) {
                                    playSound.laser(audioContextRef.current);
                                }
                                lastShotTimeRef.current = currentTime;
                            }
                        }
                    }

                    // Update ship
                    ship.angle += ship.rotation;
                    if (ship.acceleration > 0) {
                        const newDirection = {
                            x: Math.cos(ship.angle),
                            y: Math.sin(ship.angle)
                        };
                        const maxSpeed = Math.min(dimensions.width, dimensions.height) / 150;
                        ship.speed = utils.clamp(
                            ship.speed + ship.acceleration - 0.02,
                            0,
                            maxSpeed
                        );
                        lastDirection.x += (newDirection.x - lastDirection.x) * 0.015;
                        lastDirection.y += (newDirection.y - lastDirection.y) * 0.015;
                    } else {
                        ship.speed = Math.max(0, ship.speed - 0.01);
                    }

                    ship.x = (ship.x + lastDirection.x * ship.speed + dimensions.width) % dimensions.width;
                    ship.y = (ship.y + lastDirection.y * ship.speed + dimensions.height) % dimensions.height;

                    // Update stars with level-based speed
                    const levelSpeedMultiplier = 1 + (state.level - 1) * 0.2; // 20% faster per level
                    state.stars = state.stars.map(star => {
                        if (!star) return null;
                        // Yellow stars only rotate, they don't move
                        star.angle += star.rotationSpeed;
                        return star;
                    });

                    // Update death stars with level-based speed
                    state.deathStars.forEach(deathStar => {
                        const dx = ship.x - deathStar.x;
                        const dy = ship.y - deathStar.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > 0) {
                            deathStar.x += (dx / distance) * CONSTANTS.DEATH_STAR_SPEED * levelSpeedMultiplier;
                            deathStar.y += (dy / distance) * CONSTANTS.DEATH_STAR_SPEED * levelSpeedMultiplier;
                        }
                        deathStar.angle += deathStar.rotationSpeed;
                    });

                    // Update lasers
                    objectPools.current.lasers.forEach(laser => {
                        if (laser.active) {
                            laser.x += laser.dx * CONSTANTS.LASER_SPEED;
                            laser.y += laser.dy * CONSTANTS.LASER_SPEED;
                            // Deactivate if out of bounds
                            if (laser.x < 0 || laser.x > dimensions.width ||
                                laser.y < 0 || laser.y > dimensions.height) {
                                laser.active = false;
                            }
                        }
                    });

                    // Update power-up timer
                    if (ship.powerUpTime > 0) {
                        ship.powerUpTime--;
                    }

                    // Update power-up pulse animation
                    if (state.powerUp) {
                        state.powerUp.pulsePhase = (state.powerUp.pulsePhase + 0.1) % (Math.PI * 2);
                    }

                    // Check power-up collision
                    if (state.powerUp && utils.distance(
                        ship.x, ship.y,
                        state.powerUp.x, state.powerUp.y
                    ) < state.powerUp.size + CONSTANTS.SHIP_SIZE) {
                        if (audioContextRef.current) {
                            playSound.powerUp(audioContextRef.current);
                        }
                        ship.powerUpTime = CONSTANTS.POWERUP_DURATION;
                        state.powerUp = null;
                    }

                    // Check collisions
                    state.stars.forEach((star, starIndex) => {
                        if (!star) return;
                        
                        // Ship collision
                        if (utils.distance(ship.x, ship.y, star.x, star.y) < star.size + CONSTANTS.SHIP_SIZE) {
                            createExplosion(ship.x, ship.y, true);
                            if (audioContextRef.current) {
                                playSound.explosion(audioContextRef.current);
                            }
                            state.lives--;
                            if (state.lives <= 0) {
                                // Game over
                                if (state.score > state.highScore) {
                                    state.highScore = state.score;
                                    localStorage.setItem(CONSTANTS.HIGH_SCORE_KEY, state.score.toString());
                                }
                                setGameState('gameover');
                            } else {
                                // Reset ship position and all movement/input states
                                ship.x = dimensions.width / 2;
                                ship.y = dimensions.height / 2;
                                ship.speed = 0;
                                ship.angle = 0;
                                ship.rotation = 0;
                                ship.acceleration = 0;
                                ship.powerUpTime = 0;
                                state.lastDirection = { x: 0, y: 0 }; // Reset momentum
                                state.targetDirection = { x: 0, y: 0 }; // Reset target direction
                                isSpaceHeldRef.current = false;
                                lastShotTimeRef.current = 0;
                            }
                            return;
                        }

                        // Laser collisions
                        objectPools.current.lasers.forEach(laser => {
                            if (laser.active && utils.distance(laser.x, laser.y, star.x, star.y) < star.size) {
                                createExplosion(star.x, star.y, false);
                                if (audioContextRef.current) {
                                    playSound.explosion(audioContextRef.current);
                                }
                                state.stars[starIndex] = null;
                                laser.active = false;  // Deactivate the laser
                                state.score += CONSTANTS.POINTS_STAR;
                                state.killCount++;
                                
                                // Check for level up
                                if (state.killCount % 10 === 0) {
                                    if (audioContextRef.current) {
                                        playSound.levelUp(audioContextRef.current);
                                    }
                                    state.level++;
                                    // Spawn new enemies for the new level
                                    for (let i = 0; i < Math.min(state.level, 3); i++) {
                                        const enemy = createSingleEnemy(Math.random() < 0.3 ? 'death' : 'yellow');
                                        if (enemy.type === 'death') {
                                            state.deathStars.push(enemy);
                                        } else {
                                            state.stars.push(enemy);
                                        }
                                    }
                                }
                                
                                if (state.killCount % CONSTANTS.KILLS_FOR_POWERUP === 0 && !state.powerUp) {
                                    state.powerUp = createPowerUp();
                                }
                            }
                        });
                    });

                    // Death star collisions
                    state.deathStars.forEach((deathStar, deathStarIndex) => {
                        // Check collision with ship
                        if (utils.distance(ship.x, ship.y, deathStar.x, deathStar.y) < 
                            deathStar.size + CONSTANTS.SHIP_SIZE) {
                            createExplosion(ship.x, ship.y, true);
                            if (audioContextRef.current) {
                                playSound.explosion(audioContextRef.current);
                            }
                            state.lives--;
                            if (state.lives <= 0) {
                                if (state.score > state.highScore) {
                                    state.highScore = state.score;
                                    localStorage.setItem(CONSTANTS.HIGH_SCORE_KEY, state.score.toString());
                                }
                                setGameState('gameover');
                            } else {
                                // Reset ship position and all movement/input states
                                ship.x = dimensions.width / 2;
                                ship.y = dimensions.height / 2;
                                ship.speed = 0;
                                ship.angle = 0;
                                ship.rotation = 0;
                                ship.acceleration = 0;
                                ship.powerUpTime = 0;
                                state.lastDirection = { x: 0, y: 0 }; // Reset momentum
                                state.targetDirection = { x: 0, y: 0 }; // Reset target direction
                                isSpaceHeldRef.current = false;
                                lastShotTimeRef.current = 0;
                            }
                            return;
                        }

                        // Check collision with lasers
                        objectPools.current.lasers.forEach(laser => {
                            if (laser.active && utils.distance(laser.x, laser.y, deathStar.x, deathStar.y) < deathStar.size) {
                                createExplosion(deathStar.x, deathStar.y, false);
                                if (audioContextRef.current) {
                                    playSound.explosion(audioContextRef.current);
                                }
                                state.deathStars.splice(deathStarIndex, 1);
                                laser.active = false;  // Deactivate the laser
                                state.score += CONSTANTS.POINTS_DEATH_STAR;
                                state.killCount++;
                                
                                // Check for level up
                                if (state.killCount % 10 === 0) {
                                    if (audioContextRef.current) {
                                        playSound.levelUp(audioContextRef.current);
                                    }
                                    state.level++;
                                    // Spawn new enemies for the new level
                                    for (let i = 0; i < Math.min(state.level, 3); i++) {
                                        const enemy = createSingleEnemy(Math.random() < 0.3 ? 'death' : 'yellow');
                                        if (enemy.type === 'death') {
                                            state.deathStars.push(enemy);
                                        } else {
                                            state.stars.push(enemy);
                                        }
                                    }
                                }
                                
                                if (state.killCount % CONSTANTS.KILLS_FOR_POWERUP === 0 && !state.powerUp) {
                                    state.powerUp = createPowerUp();
                                }
                            }
                        });
                    });

                    // Random enemy spawning with improved balance and level-based frequency
                    if (Math.random() < 0.01 * (1 + (state.level - 1) * 0.1)) { // Increased spawn rate with level
                        spawnRandomEnemy();
                    }
                }
            }, [dimensions, gameState, createExplosion, resetGame, createSingleEnemy, spawnRandomEnemy, createPowerUp]);

            // Optimized draw function with batched rendering
            const draw = useCallback((ctx) => {
                const state = gameStateRef.current;
                
                if (gameState === 'start') {
                    drawStartScreen(ctx);
                    return;
                }
                
                if (gameState === 'gameover') {
                    drawGameOverScreen(ctx);
                    return;
                }
                
                // Clear and draw game
                ctx.clearRect(0, 0, dimensions.width, dimensions.height);
                
                // Draw grid using cached lines
                ctx.strokeStyle = 'rgb(25, 25, 25)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                cache.current.gridLines.forEach(line => {
                    ctx.moveTo(line.x1, line.y1);
                    ctx.lineTo(line.x2, line.y2);
                });
                ctx.stroke();

                // Batch render stars
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 2;
                state.stars.forEach(star => {
                    if (!star) return;
                    ctx.save();
                    ctx.translate(star.x, star.y);
                    ctx.rotate(star.angle);
                    ctx.beginPath();
                    const firstPoint = cache.current.starPoints[0];
                    ctx.moveTo(firstPoint.x * star.size, firstPoint.y * star.size);
                    for (let i = 1; i < cache.current.starPoints.length; i++) {
                        const point = cache.current.starPoints[i];
                        ctx.lineTo(point.x * star.size, point.y * star.size);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                });

                // Batch render death stars
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                state.deathStars.forEach(deathStar => {
                    ctx.save();
                    ctx.translate(deathStar.x, deathStar.y);
                    ctx.rotate(deathStar.angle);
                    
                    // Draw main shape
                    ctx.beginPath();
                    const firstPoint = cache.current.deathStarPoints[0];
                    ctx.moveTo(firstPoint.x * deathStar.size, firstPoint.y * deathStar.size);
                    for (let i = 1; i < cache.current.deathStarPoints.length; i++) {
                        const point = cache.current.deathStarPoints[i];
                        ctx.lineTo(point.x * deathStar.size, point.y * deathStar.size);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    // Draw inner circle
                    ctx.beginPath();
                    ctx.arc(0, 0, deathStar.size * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                });

                // Batch render lasers
                if (gameState === 'playing' || gameState === 'exploding') {
                    // Draw ship with enhanced flame
                    if (gameState === 'playing' || gameState === 'exploding') {
                        ctx.save();
                        ctx.translate(state.ship.x, state.ship.y);
                        ctx.rotate(state.ship.angle);

                        // Draw enhanced flame when accelerating
                        if (state.ship.acceleration > 0) {
                            const flameSize = CONSTANTS.SHIP_SIZE * 0.4; // Halved the flame size
                            // Draw main flame with alternating colors
                            const colorTime = Date.now() % 200 < 100; // Alternates every 100ms
                            
                            ctx.beginPath();
                            ctx.moveTo(-CONSTANTS.SHIP_SIZE, 0);
                            const jitter = () => (Math.random() - 0.5) * 2;
                            ctx.lineTo(-CONSTANTS.SHIP_SIZE - flameSize + jitter(), jitter());
                            ctx.lineTo(-CONSTANTS.SHIP_SIZE, 0);
                            
                            // Alternate between red and yellow gradients
                            const gradient = ctx.createLinearGradient(
                                -CONSTANTS.SHIP_SIZE, 0,
                                -CONSTANTS.SHIP_SIZE - flameSize, 0
                            );
                            if (colorTime) {
                                gradient.addColorStop(0, '#FF4500');
                                gradient.addColorStop(1, '#FFD700');
                            } else {
                                gradient.addColorStop(0, '#FFD700');
                                gradient.addColorStop(1, '#FF4500');
                            }
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            // Add spark effect
                            for (let i = 0; i < 2; i++) { // Reduced number of sparks for optimization
                                const sparkDist = Math.random() * flameSize;
                                const sparkAngle = (Math.random() - 0.5) * Math.PI / 4;
                                ctx.beginPath();
                                ctx.arc(
                                    -CONSTANTS.SHIP_SIZE - sparkDist * 0.8,
                                    Math.sin(sparkAngle) * sparkDist * 0.3,
                                    0.8, // Smaller sparks
                                    0,
                                    Math.PI * 2
                                );
                                ctx.fillStyle = colorTime ? '#FFD700' : '#FF4500';
                                ctx.fill();
                            }
                        }

                        // Draw ship
                        ctx.beginPath();
                        ctx.moveTo(CONSTANTS.SHIP_SIZE, 0);
                        ctx.lineTo(-CONSTANTS.SHIP_SIZE, -CONSTANTS.SHIP_SIZE * 0.7);
                        ctx.lineTo(-CONSTANTS.SHIP_SIZE, CONSTANTS.SHIP_SIZE * 0.7);
                        ctx.closePath();
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Batch draw lasers
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    objectPools.current.lasers.forEach(laser => {
                        if (laser.active) {
                            ctx.moveTo(laser.x, laser.y);
                            ctx.lineTo(
                                laser.x + laser.dx * CONSTANTS.LASER_LENGTH,
                                laser.y + laser.dy * CONSTANTS.LASER_LENGTH
                            );
                        }
                    });
                    ctx.stroke();
                }

                // Batch render particles with proper colors and fading
                objectPools.current.particles.forEach(particle => {
                    if (particle.active) {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                        if (particle.color === 'white') {
                            ctx.fillStyle = `rgba(255, 255, 255, ${particle.life})`;
                        } else {
                            ctx.fillStyle = `rgba(255, 255, 0, ${particle.life})`;
                        }
                        ctx.fill();
                    }
                });

                // Draw power-up
                if (state.powerUp) {
                    ctx.save();
                    ctx.translate(state.powerUp.x, state.powerUp.y);
                    const pulseScale = 1 + Math.sin(state.powerUp.pulsePhase) * 0.2;
                    ctx.scale(pulseScale, pulseScale);
                    ctx.beginPath();
                    ctx.arc(0, 0, state.powerUp.size, 0, Math.PI * 2);
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                }

                // Draw HUD
                ctx.save();
                ctx.font = '20px "Courier New", monospace';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'white';
                
                // Batch render HUD text
                const hudTexts = [
                    { text: `SCORE: ${state.score}`, x: dimensions.width / 2, y: 30 },
                    { text: `LEVEL: ${state.level}`, x: 20, align: 'left', y: 30 },
                    { text: `LIVES: ${state.lives}`, x: dimensions.width - 20, align: 'right', y: 30 }
                ];
                
                hudTexts.forEach(({ text, x, y, align }) => {
                    if (align) ctx.textAlign = align;
                    ctx.fillText(text, x, y);
                });
                
                if (state.ship.powerUpTime > 0) {
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'blue';
                    ctx.fillText(`DUAL BEAM: ${Math.ceil(state.ship.powerUpTime / 60)}s`, dimensions.width / 2, 60);
                }
                ctx.restore();

                if (gameState === 'paused') {
                    drawPauseScreen(ctx);
                }
            }, [dimensions, gameState, drawStartScreen, drawGameOverScreen, drawPauseScreen]);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                // Set canvas size
                canvas.width = dimensions.width;
                canvas.height = dimensions.height;

                // Initialize game state
                resetGame();
                
                const handleResize = () => {
                    setDimensions({
                        width: window.innerWidth,
                        height: window.innerHeight
                    });
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };

                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [dimensions.width, dimensions.height, resetGame]);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const state = gameStateRef.current;

                const handleKeyDown = (e) => {
                    if (e.code === 'Space') e.preventDefault();
                    
                    if (gameState === 'start' && e.code === 'Space') {
                        setGameState('playing');
                        resetGame();
                        return;
                    }
                    
                    if (gameState === 'gameover' && e.code === 'Space') {
                        setGameState('playing');
                        resetGame();
                        return;
                    }
                    
                    if (e.key === 'p' || e.key === 'P') {
                        if (gameState === 'playing') {
                            setGameState('paused');
                        } else if (gameState === 'paused') {
                            setGameState('playing');
                        }
                        return;
                    }
                    
                    if (gameState !== 'playing') return;
                    
                    switch (e.key) {
                        case 'ArrowLeft':
                            state.ship.rotation = -CONSTANTS.SHIP_ROTATION_SPEED;
                            break;
                        case 'ArrowRight':
                            state.ship.rotation = CONSTANTS.SHIP_ROTATION_SPEED;
                            break;
                        case 'ArrowUp':
                            state.ship.acceleration = CONSTANTS.SHIP_ACCELERATION;
                            break;
                        case ' ':
                            if (!isSpaceHeldRef.current) {
                                isSpaceHeldRef.current = true;
                                // First shot happens immediately on press
                                const currentTime = Date.now();
                                // Only fire if enough time has passed since last shot
                                if (currentTime - lastShotTimeRef.current >= SHOT_COOLDOWN) {
                                    const angle = state.ship.angle;
                                    let shotFired = false;

                                    if (state.ship.powerUpTime > 0) {
                                        const laser1 = createLaser(state.ship, angle - 0.1);
                                        const laser2 = createLaser(state.ship, angle + 0.1);
                                        if (laser1 && laser2) {
                                            shotFired = true;
                                        }
                                    } else {
                                        const laser = createLaser(state.ship, angle);
                                        if (laser) {
                                            shotFired = true;
                                        }
                                    }

                                    if (shotFired) {
                                        if (audioContextRef.current) {
                                            playSound.laser(audioContextRef.current);
                                        }
                                        lastShotTimeRef.current = currentTime;
                                    }
                                }
                            }
                            break;
                    }
                };

                const handleKeyUp = (e) => {
                    if (gameState !== 'playing') return;

                    switch (e.key) {
                        case 'ArrowLeft':
                        case 'ArrowRight':
                            state.ship.rotation = 0;
                            break;
                        case 'ArrowUp':
                            state.ship.acceleration = 0;
                            break;
                        case ' ':
                            isSpaceHeldRef.current = false;
                            break;
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [gameState, resetGame, createLaser]);

            // Game loop effect
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                let frameId;
                let lastTime = 0;
                
                const gameLoop = (timestamp) => {
                    // Calculate delta time
                    const deltaTime = timestamp - lastTime;
                    lastTime = timestamp;

                    // Only update game state if not paused
                    if (gameState !== 'paused') {
                        updateGameState(deltaTime);
                    }
                    
                    // Always draw
                    draw(ctx);
                    frameId = requestAnimationFrame(gameLoop);
                };

                // Start the game loop
                frameId = requestAnimationFrame(gameLoop);

                return () => {
                    cancelAnimationFrame(frameId);
                };
            }, [gameState, updateGameState, draw]);

            // Update grid cache on resize
            useEffect(() => {
                updateGridCache();
            }, [dimensions, updateGridCache]);

            // Initialize starfield with independent parallax layers
            useEffect(() => {
                const starfieldCanvas = starfieldRef.current;
                const starfieldCtx = starfieldCanvas.getContext('2d');
                
                // Create three distinct layers of background stars
                const parallaxLayers = [
                    { count: 100, speed: 0.1, size: 1, color: `${CONSTANTS.VECTOR_COLOR}40` },
                    { count: 50, speed: 0.2, size: 1.5, color: `${CONSTANTS.VECTOR_COLOR}80` },
                    { count: 25, speed: 0.3, size: 2, color: CONSTANTS.VECTOR_COLOR }
                ];

                // Initialize stars for each layer
                const layers = parallaxLayers.map(layer => 
                    Array.from({ length: layer.count }, () => ({
                        x: Math.random() * dimensions.width,
                        y: Math.random() * dimensions.height,
                        size: layer.size,
                        speed: layer.speed,
                        color: layer.color,
                        baseX: Math.random() * dimensions.width,  // Store original position
                        baseY: Math.random() * dimensions.height
                    }))
                );

                const drawStarfield = () => {
                    starfieldCtx.fillStyle = 'black';
                    starfieldCtx.fillRect(0, 0, dimensions.width, dimensions.height);

                    // Draw each layer of stars
                    layers.forEach(stars => {
                        stars.forEach(star => {
                            starfieldCtx.fillStyle = star.color;
                            starfieldCtx.beginPath();
                            starfieldCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                            starfieldCtx.fill();
                        });
                    });
                };

                const updateStarfield = () => {
                    const ship = gameStateRef.current.ship;
                    const offsetX = -ship.speed * Math.cos(ship.angle) * 2;
                    const offsetY = -ship.speed * Math.sin(ship.angle) * 2;

                    // Update each layer with different parallax speeds
                    layers.forEach((stars, layerIndex) => {
                        stars.forEach(star => {
                            // Calculate new position based on ship movement and star's layer speed
                            star.x = (star.x + offsetX * star.speed + dimensions.width) % dimensions.width;
                            star.y = (star.y + offsetY * star.speed + dimensions.height) % dimensions.height;
                            
                            // Add subtle twinkling effect
                            star.color = star.color.replace(/[\d.]+\)$/,
                                `${0.3 + Math.sin(Date.now() * 0.001 + star.baseX) * 0.2})`);
                        });
                    });

                    drawStarfield();
                };

                // Set initial canvas size
                const handleResize = () => {
                    starfieldCanvas.width = window.innerWidth;
                    starfieldCanvas.height = window.innerHeight;
                };

                window.addEventListener('resize', handleResize);
                handleResize();

                const intervalId = setInterval(updateStarfield, 1000 / 60);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    clearInterval(intervalId);
                };
            }, [dimensions]);

            return (
                <>
                    <canvas ref={starfieldRef} id="starfield" />
                    <canvas ref={canvasRef} width={dimensions.width} height={dimensions.height} />
                </>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
   <script>
        // Initialize audio context on first user interaction
        document.addEventListener('click', function initAudio() {
            if (window.audioContext) {
                window.audioContext.resume();
            }
            document.removeEventListener('click', initAudio);
        });
    </script>

</body>
</html>
